<?php

namespace App\Helpers;

class SqlDebugHelper
{
  /**
   * Class SqlDebugHelper
   *
   * Helper utilities for debugging SQL queries generated by the application.
   * Provides methods to inject binding values into parameterized SQL and to
   * produce a more human-readable, pretty-printed representation of SQL
   * statements for logging or debugging purposes.
   *
   * Notes:
   * - The helper is intended for debugging and logging only. Injected bindings
   *   are not escaped for database execution; do not use the output for
   *   executing queries.
   * - Designed to work with SQL strings containing positional parameter
   *   placeholders ("?") and a corresponding numeric-indexed $bindings array.
   */

  /**
   * Replace positional placeholders ("?") in a SQL string with the supplied bindings.
   *
   * This method iterates through the provided $bindings array and replaces the
   * first occurrence of "?" in $sql with the corresponding binding value,
   * one-by-one, preserving order.
   *
   * Behavior:
   * - Numeric bindings (is_numeric) are inserted as-is.
   * - Non-numeric bindings are wrapped in single quotes.
   * - Replacement is performed sequentially; each "?" is replaced once.
   *
   * Limitations / Caveats:
   * - Bindings are not escaped for SQL injection safety; this function is meant
   *   only for debugging/logging and not for executing queries.
   * - Complex binding types (e.g. arrays, objects, DateTime) are not specially
   *   handled and may need conversion before use.
   *
   * @param string $sql      The SQL query string containing "?" positional placeholders.
   * @param array  $bindings Indexed array of binding values to insert into the SQL.
   * @return string          The SQL string with placeholders replaced by formatted bindings.
   */
  public static function replaceBindings($sql, $bindings)
  {
    foreach ($bindings as $binding) {
      $binding = is_numeric($binding) ? $binding : "'$binding'";
      $sql = preg_replace('/\?/', $binding, $sql, 1);
    }
    return $sql;
  }

  /**
   * Prettify and format a SQL statement for improved readability.
   *
   * This method optionally injects bindings into the SQL (using replaceBindings)
   * when $bindings is provided, then inserts newlines before major SQL keywords
   * and applies a simple indentation scheme to make the query easier to read.
   *
   * Formatting rules:
   * - Inserts a newline before keywords such as SELECT, FROM, WHERE, GROUP BY,
   *   ORDER BY, various JOINs, UNION, AND, OR, and ON.
   * - Trims and splits the SQL into lines, then applies indentation levels:
   *   - SELECT lines: base indentation (level 0)
   *   - FROM, WHERE, GROUP BY, ORDER BY, UNION: indent level 1
   *   - AND, OR, ON: indent level 2
   *
   * Notes:
   * - The prettifier uses regular expressions for keyword detection; very
   *   complex or non-standard SQL may not format as expected.
   * - This is intended for human-readable output only and should not be used to
   *   transform SQL for execution.
   *
   * @param string $sql       The raw SQL string to format.
   * @param array  $bindings  Optional array of bindings to replace positional
   *                          placeholders before formatting. Defaults to empty.
   * @return string           The prettified SQL string with newlines and indentation.
   */
  public static function prettify($sql, $bindings = [])
  {
    $fullSql = empty($bindings)
      ? $sql
      : self::replaceBindings($sql, $bindings);

    $patterns = [
      '/\b(SELECT)\b/i',
      '/\b(FROM)\b/i',
      '/\b(WHERE)\b/i',
      '/\b(GROUP BY)\b/i',
      '/\b(ORDER BY)\b/i',
      '/\b(LEFT JOIN)\b/i',
      '/\b(RIGHT JOIN)\b/i',
      '/\b(INNER JOIN)\b/i',
      '/\b(OUTER JOIN)\b/i',
      '/\b(UNION ALL)\b/i',
      '/\b(UNION)\b/i',
      '/\b(AND)\b/i',
      '/\b(OR)\b/i',
      '/\b(ON)\b/i',
    ];
    $formatted = preg_replace($patterns, "\n\$1", $fullSql);

    $lines = explode("\n", trim($formatted));
    $indented = '';
    $indentLevel = 0;

    foreach ($lines as $line) {
      $line = trim($line);

      if (preg_match('/^(FROM|WHERE|GROUP BY|ORDER BY|UNION)/i', $line)) {
        $indentLevel = 1;
      } elseif (preg_match('/^(AND|OR|ON)/i', $line)) {
        $indentLevel = 2;
      } elseif (preg_match('/^(SELECT)/i', $line)) {
        $indentLevel = 0;
      }

      $indented .= str_repeat('    ', $indentLevel) . $line . "\n";
    }

    return trim($indented);
  }
}
